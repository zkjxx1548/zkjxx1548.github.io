# g的用法

对于表达式对象的exec方法，不加入g，则只返回第一个匹配，无论执行多少次均是如此，如果加入g，则第一次执行也返回第一个匹配，再执行返回第二个匹配，依次类推。例如 
var regx=/user\d/; 
var str=“user18dsdfuser2dsfsd”; 
var rs=regx.exec(str);//此时rs的值为{user1} 
var rs2=regx.exec(str);//此时rs的值依然为{user1} 
如果regx=/user\d/g；则rs的值为{user1}，rs2的值为{user2} 
通过这个例子说明：对于exec方法，表达式加入了g，并不是说执行exec方法就可以返回所有的匹配，而是说加入了g之后，我可以通过某种方式得到所有的匹配，这里的“方式”对于exec而言，就是依次执行这个方法即可。 

2）对于表达式对象的test方法，加入g于不加上g没有什么区别。 

3）对于String对象的match方法，不加入g，也只是返回第一个匹配，一直执行match方法也总是返回第一个匹配，加入g，则一次返回所有的匹配（注意这与表达式对象的exec方法不同，对于exec而言，表达式即使加上了g，也不会一次返回所有的匹配）。例如： 
var regx=/user\d/; 
var str=“user1sdfsffuser2dfsdf”; 
var rs=str.match(regx);//此时rs的值为{user1} 
var rs2=str.match(regx);//此时rs的值依然为{user1} 
如果regx=/user\d/g，则rs的值为{user1,user2}，rs2的值也为{user1,user2} 

4）对于String对象的replace方法，表达式不加入g，则只替换第一个匹配，如果加入g，则替换所有匹配。（开头的三道测试题能很好的说明这一点） 

5）对于String对象的split方法，加上g与不加g是一样的，即： 
var sep=/user\d/; 
var array=“user1dfsfuser2dfsf”.split(sep); 
则array的值为{dfsf, dfsf} 
此时sep=/user\d/g，返回值是一样的。 

6）对于String对象的search方法，加不加g也是一样的。 



# 核心

1. 串接 `ab`
2. 选择`a|b`
3. 克莱尼星号`a*`

# 字符集合[]

1. 非\[^]
2. 或：[]内部默认或
3. 连接[A-B]

# 特殊字集

1. 换行`/n`
2. 数字`/d`，非数字`/D`
3. 大小写、下划线和数字`/w`，取反`/W`
4. `/w`的边界：`/b`
5. 行的起始`^`，行的结束`$`
6. 任何字符`.`

# 量词

1. 0或多个`*`

2. 0或1个`?`

3. 1个或多个`+`

4. m个到n个`{m,n}`

5. m个或多个`{m,}`

6. m个`{m}`

   