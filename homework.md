## 1.2.2

1. 数据类型

   * 基本数据类型
     * `Boolean`：布尔值，有`true`和`false`
     * `Null`：表明“空”的值
     * `Undefined`：表明变量未定义时的属性
     * `Number`：表示数字，有范围，超出范围数据不安全，不准确
     * `BigInt`：表示数字，相比在Number的范围外是安全的。
     * `String`：表示字符串
     * `Symbol`：其实例唯一且不可变
   * `Object`类型：引用类型

2. 区别：

   * 存储方式：基本类型存储在栈中，其值直接存储在变量访问的位置。引用数据类型存储在堆中的对象，存储在变量出的值是一个指针，指向存储对象的内存处，放在栈空间的值是该对象存储在堆中的地址。

   * 基本类型按值传递，值不可变，只有对象可变，看似“修改”，其实是创建新的值，函数形参是被调用时所传实参的副本。引用类型按引用传递，值可变，函数的形参接受实参的隐式引用，不再是副本。
   * 基本类型不能添加属性和方法
   * 用`==`比较时，基本数据类型比较变量的值，引用数据类型比较两个对象在堆中的地址是否相同

3. 变量提升：

   * 函数声明和变量声明总是会被解释器“提升”到方法体的最顶部。所以可以在使用变量后再声明。
   * 只有声明的变量会提升，如`var x;`，初始化的不会，如`var x=5;`。
   * 为避免产生不必要问题，通常在每个作用域前声明变量。

4. `typeof`：返回一个字符串，表示未经计算的操作数的类型。

   ```js
   undefined
   boolean
   number
   string
   object
   ```

## 1.2.3

1. `num++`和`++num`的区别
   
* 前者会将值做计算值，再自加1。后者是先自加1，再将值做计算值。
  
2. 用`Math`方法对结果进行操作
   * 保留两位小数：`Math.round(num*100) / 100`;
   * 四舍五入：`Math.round(num)`;
   * 向上取整：`Math.ceil(num)`;
   * 向下取整：`Math.floor(num)`;

3. 计算结果：
   * `42 == "42";`---------`true`
   
   * `42 === "42";`---------`false`
   
   * `"foo" == ["foo"];`------`false`
   
   * `"0" == false;`------------`false`
   
   * `"" == [];`------------------`false`
   
   * `"" == 0;`--------------------`false`
   
   * `[] == 0;`--------------------`false`
   
   * `"true" == true;`-----------`false`
   
     * 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——`false`转换为`0`，而`true`转换为`1`；这时为`"true" == 1;`
   
     * 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；这里用`Number()`转化:
   
       1. 如果字符串中只包含数字（包括前面带加号或负号的情况），则将其转换为十进制数值， 即`"1"`会变成`1`，`"123"`会变成`123`，而`"011"`会变成`11`（前导的零会被忽略了）；
   
       2. 如果字符串中包含有效的浮点格式，如`"1.1"`，则将其转换为对应的浮点数值（也会忽略前导零）
   
       3. 如果字符串中包含有效的十六进制格式，例如`"0xf"`，则将其转换为相同大小的十进制整数值；
   
       4. 如果字符串是空的（不包含任何字符），则将其转换为`0`
   
       5. 如果字符串中包含除上述格式之外的字符，则将其转换为`NaN`
   
     * 这里适用第5条转化为`NaN == 1;`
   
     * 因为`NaN`不与任何值相等，包括本身。这里答案为`false`
   
   * `0 == "\n";`-------------------`false`
   
   * `0 == null;`-------------------`false`
   
   * `false == {};`----------------`false`
   
   * `0.1 + 0.2 == 0.3;`---------`false`
4. 计算，并说明为什么：
   * 第一处：`42`，因为`a++`为先计算后自加
   * 第二处：`43`，因为上面计算完后，`a`自加了`1`
   * 第三处：`44`，因为`++a`为先自加，后计算
   * 第四处：`44`，因为上面的`a`自加后为`44`

5. 计算，并说明原因：
   * 第一处：`8`，`&`是运算符按位与，左右不是二进制时，把左右两边转化为二进制，每一位进行比较，相等为`1`，不同为`0`。`42`的二进制为`00101010`，`24`的二进制为`00011000`，作`&`运算后为`00001000`。
   * 第二处：`34`，`&&`是逻辑运算符与，左边为真走右边，左边为假只走左边。`false`，`undefined`，`''`，`null`，`0`和`NaN`被认定为假。这里左边是`8`，为真，走右边。
   * 第三处：`54`，`|`是位的或运算符，同时转化为二进制，每一位比较，只要有一个`1`，结果为`1`，否则为`0`。左边`34`的二进制为`00100010`，右边`54`的二进制为`00110110`，作`|`后为`001100110`。
   * 第四处：`54`，`||`是逻辑或运算符，只要左右为`false`，返回右边；只要左边为`true`，都返回左边。这里左边是`54`，为真，返回左边。

## 1.2.4

1. 判断成绩

   ```js
   var result;
   if (result >= 95) {
     console.log("卓越");
   }else if (result >= 85) {
     console.log("优秀");
   }else if (result >= 75) {
     console.log("一般");
   }else if (result >=60) {
     console.log("及格")
   }else {
     console.log("不及格")
   }
   
   ```

2. 简易计算器：

   ```js
   var x = 10, y = 8, operator;
   switch (operator) {
     case '+':
       console.log(x + y);
       break;
     case '-':
       console.log(x - y);
       break;
     case '*':
       console.log(x * y);
       break;
     case '/':
       console.log(x / y);
       break;
     case '%':
       console.log(x % y);
       break;
   }
   ```

3. 累加1~100，跳过个位为3的数：

   ```js
   let n = 1;
   let sum = 0;
   while (n <= 100) {
     if (n % 10 != 3) {
       sum += n;
     }
     n++;
   }
   console.log(sum);
   ```

4. 打印`*`矩阵：

   ```js
   var a = "";
   for (let i = 6; i > 0; i--) {
     for (let j = i; j > 0; j--) {
       a += "*" + " ";
     }
     a += "\n";
   }
   console.log(a);
   ```

5. 打印99乘法表：

   ```js
   var a = "";
   for (let i = 1; i < 10; i++) {
     for (let j = 1; j <= i; j++) {
       a = a + i + "*" + j + "=" + i*j + " ";  
     }
     a += "\n";
   }
   console.log(a);
   ```

## 1.2.5

1. 四种：

   * 使用function语句

     ```js
     function sum(a, b) {
       return a + b;
     }
     //解析器会自动提升函数至代码的头部
     ```

   * 使用Function()构造函数

     ```js
     var sum = new Function("a", "b", "return a + b;");
     //不常用
     ```

   * 使用函数表达式

     ```js
     var sum = function(a, b) {
       return a + b;
     }
     //不会让函数名声明提起那，符合先定义后使用的要求。
     ```

   * 自调用函数

     ```js
     (function () {
       return a + b;
     })();
     /*
     自动调用，也称立即执行函数，条件：表达式后面紧跟()。但不能自调用声明的函数。
     */
     ```

     

2. `b = 5;`这里使用函数自调用，函数立即执行，并且函数内部的`var`声明的变量会提升为全局变量。

3. 代码：

   ```js
   var str, n;
   var repeatStr = function(str, n) {
     var newStr = "";
     if (n > 0) {
       for (let i = 0; i < n; i++) {
         newStr += str;
       }
     }else {
       newStr = str;
     }
     return newStr;
   }
   ```

4. 结果：

   ```js
   undefined;  
   /*函数内部的var声明的变量会提升至全局变量，导致test内部的console.log(a)前面没有声明变量a，所以在内部打印a，属未定义类型。
   */
   2； //test内部，foo()会提升至顶部，所以打印foo不出错。
   ```

5. 结果：

   ```js
   function;//var声明会自动放在代码头部，这里foo没有定义数据类型，可以看作函数表达式方式创建函数。
   number; 
   /*
   函数声明和变量声明都会置顶，且函数声明优先级更高（函数代码在变量上面）
   声明过的变量不会重新声明
   */
   这里第二小题约等于：
   var foo = function() {
     return 1;
   }
   var foo = 1;
   //也就是说foo被重新赋值了，不再是函数了。
   ```

6. 乘法计算器：

   ```js
   var multiplicationCaculator = function() {
     var result = 1;
     for (var i = 0; i < arguments.length; i++) {
       result *= arguments[i];
     }
     return result;
   }
   ```

7. 代码：

   ```js
   var add = function(a) {
     var add1 = function(b) {
         return add(a + b);
     }
     add1.toString = function() {
       return a;
     }
     return add1;
   }
   /*
   函数的toString方法会返回一个表示函数源代码的字符串，包括function关键字，形参列表，大括号，以及函数体中的内容。如果调用者不是函数，会报错。这里调用者为add1。函数add返回函数add1，如果add1没有参数了，则add1返回的是add(a)；接下来顺序调用add1的toString函数，返回其参数列表a。
   */
   ```

   

## 1.2.6



